<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/~s0661023/2020/04/04/hello-workd/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a> 
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
  <entry>
    <title>編譯器的原理(1)--計算機組織介紹</title>
    <url>/~s0661023/2020/04/15/compiler_1/</url>
    <content><![CDATA[<h2 id="什麼是計算機"><a href="#什麼是計算機" class="headerlink" title="什麼是計算機?"></a>什麼是計算機?</h2><h3 id="思考-構成計算機需要哪些要素"><a href="#思考-構成計算機需要哪些要素" class="headerlink" title="思考:構成計算機需要哪些要素?"></a>思考:構成計算機需要哪些要素?</h3><ul>
<li>狀態<ul>
<li>數字表示<ul>
<li>ASCII</li>
<li>分類</li>
<li>商品</li>
<li>語言</li>
</ul>
</li>
<li>單數字不夠(需要Array)</li>
</ul>
</li>
<li>輸入<ul>
<li>時間作為一種標準輸入<ul>
<li>晶體振動<ul>
<li>利用電頻高和低的轉換週期來定義時間</li>
</ul>
</li>
</ul>
</li>
<li>通過設備讀取<ul>
<li>滑鼠，鍵盤</li>
</ul>
</li>
<li>讀取人類想法<ul>
<li>腦電波</li>
</ul>
</li>
</ul>
</li>
<li>狀態轉換函數F(輸入和當前狀態轉換成下一種狀態)<ul>
<li>表格</li>
<li>邏輯</li>
<li>如果鼠標在1024*768螢幕上有786432種位置，則需要用表格描述很大的空間該如何優化?<ul>
<li>用程式描述狀態轉換函數<ul>
<li>每次鼠標位置更新，調用某程式計算並顯示位置</li>
<li>程式預先在計算機安裝好</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>輸出<ul>
<li>讀取計算機狀態<ul>
<li>螢幕</li>
<li>印表機</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a> 

<h3 id="差分機-Difference-engine，機械計算機"><a href="#差分機-Difference-engine，機械計算機" class="headerlink" title="差分機(Difference engine，機械計算機)"></a>差分機(Difference engine，機械計算機)</h3><ul>
<li>1820-1830年，英國科學家<strong>查爾斯·巴貝奇</strong>研發的自動化數學機器，可以計算多項式求值的機器。<br><img src="https://i.imgur.com/i2mWCvn.jpg" alt=""></li>
</ul>
<h3 id="圖靈機-Turing-machine，又稱確定型圖靈機"><a href="#圖靈機-Turing-machine，又稱確定型圖靈機" class="headerlink" title="圖靈機(Turing machine，又稱確定型圖靈機)"></a>圖靈機(Turing machine，又稱確定型圖靈機)</h3><ul>
<li>英國數學家，邏輯學家，密碼分析家<strong>艾倫·圖靈(1912-1954)</strong>，被譽為計算機科學之父<ul>
<li>圖靈機</li>
<li>圖靈測試</li>
<li>圖靈完備性</li>
<li>可判定性</li>
</ul>
</li>
<li>於1936年提出的一種將人的計算行為抽象掉的數學邏輯機</li>
<li><img src="https://i.imgur.com/8diGIcr.jpg" alt=""></li>
</ul>
<h3 id="馮．諾依曼模型"><a href="#馮．諾依曼模型" class="headerlink" title="馮．諾依曼模型"></a>馮．諾依曼模型</h3><ul>
<li>匈牙利裔美國數學家<strong>馮．諾依曼(1903-1957)</strong>，現代計算機理論和博奕論奠基者<ul>
<li>離散變量自動電子計算機(EDVAC)</li>
<li>算子理論，測度論，量子力學…等</li>
</ul>
</li>
<li><img src="https://i.imgur.com/9p6hg3V.png" alt=""></li>
</ul>
<h2 id="CPU如何執行指令"><a href="#CPU如何執行指令" class="headerlink" title="CPU如何執行指令?"></a>CPU如何執行指令?</h2><h3 id="人腦之於計算機"><a href="#人腦之於計算機" class="headerlink" title="人腦之於計算機"></a>人腦之於計算機</h3><table>
<thead>
<tr>
<th>人腦</th>
<th>計算機</th>
</tr>
</thead>
<tbody><tr>
<td>短期記憶</td>
<td>寄/暫存器(Register)</td>
</tr>
<tr>
<td>邏輯推理</td>
<td>算數邏輯單元(ALU)</td>
</tr>
<tr>
<td>長期記憶</td>
<td>隨機存儲記憶體(RAM)</td>
</tr>
<tr>
<td>其他(中短期記憶)</td>
<td>CPU Cache —— L1, L2, L3</td>
</tr>
</tbody></table>
<h3 id="寄-暫存器-Register"><a href="#寄-暫存器-Register" class="headerlink" title="寄/暫存器(Register)"></a>寄/暫存器(Register)</h3><ul>
<li>寄/暫存器是有限存貯容量的高速存貯部件，它們可用來暫存指令、資料和位址</li>
<li>寄/暫存器是記憶體階層中的最頂端，也是系統操作資料的最快速途徑</li>
<li>重要的種類<ul>
<li>程式計數器PC(Program Counter)<ul>
<li>指示下一個待執行指令的記憶體位址</li>
</ul>
</li>
<li>記憶體位址寄/暫存器MAR(Memory Address Register)<ul>
<li>儲存至記憶體存取資料的位址，而提供位址的來源為<strong>PC</strong>或<strong>MBR</strong></li>
</ul>
</li>
<li>記憶體緩衝寄/暫存器MBR(Memory Buffer Register)<ul>
<li>儲存將存取至<strong>記憶體的資料</strong></li>
</ul>
</li>
<li>指令寄/暫存器IR(Instruction Register)<ul>
<li>儲存<strong>待執行的運算碼</strong></li>
</ul>
</li>
<li>指令解碼器ID(Instruction Decoder)<ul>
<li>對待執行的指令解碼，並<strong>產生控制信號給ALU</strong>(算數邏輯單元)</li>
</ul>
</li>
<li>算數邏輯單元(ALU)<ul>
<li>對運算碼所產生的控制碼對運算元作運算</li>
</ul>
</li>
</ul>
</li>
<li>數量不多<ul>
<li>早期80x86有8個</li>
<li>i7有24個</li>
</ul>
</li>
</ul>
<h3 id="算數邏輯單元-ALU"><a href="#算數邏輯單元-ALU" class="headerlink" title="算數邏輯單元(ALU)"></a>算數邏輯單元(ALU)</h3><ul>
<li>寄/暫存器中的參數導入ALU，ALU計算完結果返回寄/暫存器</li>
<li>由<strong>AND gate</strong>和<strong>OR gate</strong>構成的算數邏輯單元，進行<strong>二進位的算術運算</strong>，如<strong>加減乘(不包括整數除法)</strong></li>
</ul>
<h3 id="隨機存儲記憶體-RAM"><a href="#隨機存儲記憶體-RAM" class="headerlink" title="隨機存儲記憶體(RAM)"></a>隨機存儲記憶體(RAM)</h3><ul>
<li>當記憶體中的訊息被讀取或寫入時，所需要的時間與這段資料的位址無關</li>
<li>相對寄/暫存器還是慢</li>
<li>記憶體儲存單位–位元組(byte)<ul>
<li>位元組（byte)：<strong>8位元</strong></li>
<li>字組長度：8位元的整數倍</li>
<li>字組：可為<strong>數字</strong>、<strong>指令</strong>、<strong>字符</strong></li>
</ul>
</li>
<li>指令<ul>
<li>LOAD A, 1000<ul>
<li>記憶體位址為1000的資料，從記憶體中通過電路存到寄/暫存器A中，寄/暫存器則是以32位數儲存，如001000 0000 0000000000001111101000<ul>
<li>001000為OP code(運算碼)，代表LOAD</li>
<li>0000為寄/暫存器A</li>
<li>0000000000001111101000為記憶體位址1000</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="程式計數器-Program-Counter，PC"><a href="#程式計數器-Program-Counter，PC" class="headerlink" title="程式計數器(Program Counter，PC)"></a>程式計數器(Program Counter，PC)</h3><ul>
<li>用於指示電腦在其程式序列中的位置</li>
<li>指令指標都是在提取程式指令後就被立即增加(意指<strong>跳躍指令的目的位址</strong>)，是由跳躍指令的運算元加上跳躍指令之後下一個指令的位址(單位爲位元或位元組，視電腦形態而定)來獲得目的地</li>
</ul>
<h3 id="指令週期-簡單"><a href="#指令週期-簡單" class="headerlink" title="指令週期(簡單)"></a>指令週期(簡單)</h3><p><img src="https://i.imgur.com/FiZ7Lsx.jpg" alt=""></p>
<ol>
<li>擷取，控制單元從主記憶體中<strong>提取下一個所要執行的指令</strong><ul>
<li>CPU內有<strong>程序計數器(PC)</strong>，它儲存下一個要執行的指令的地址。處理器按PC儲存的地址，經主記憶體取得指令的內容，PC加1，經數據匯流排將指令存入指令暫存器(IR)</li>
</ul>
</li>
<li>解碼，控制單元<strong>將指令解碼</strong><ul>
<li>將指令寄/暫存器(IR)內的指令譯成機器語言</li>
</ul>
</li>
<li>執行，控制單元將指令中的執行動作，存入<strong>指令寄/暫存器</strong></li>
<li>儲存，控制單元將指令中相關資料所儲存之位置，存入<strong>位址寄/暫存器</strong></li>
</ol>
<h3 id="指令週期-完整"><a href="#指令週期-完整" class="headerlink" title="指令週期(完整)"></a>指令週期(完整)</h3><ol>
<li>擷取運算碼</li>
<li>解碼</li>
<li>擷取運算元</li>
<li>執行</li>
<li>儲存執行結果</li>
</ol>
<h3 id="CPU執行過程-簡單"><a href="#CPU執行過程-簡單" class="headerlink" title="CPU執行過程(簡單)"></a>CPU執行過程(簡單)</h3><ol>
<li>在記憶體100的位址時，執行LOAD A, 1000，寄/暫存器A存放1000位址的值(5000)</li>
<li>PC往下指到104的位址，執行LOAD B, 1008，寄/暫存器B存放1008位址的值(0.2)</li>
<li>PC往下指到108的位址，執行Multiply C, A, B，將A和B位址的值做相乘，並在寄/暫存器C中存放該值(1000)</li>
<li>PC往下指到112的位址，執行Store C, 1016，儲存寄/暫存器C的值(1000)到記憶體1016的位址<br><img src="https://i.imgur.com/ARhFgE8.gif" alt=""></li>
</ol>
<h3 id="CPU執行過程-完整"><a href="#CPU執行過程-完整" class="headerlink" title="CPU執行過程(完整)"></a>CPU執行過程(完整)</h3><ul>
<li><p>執行範例<br>  <img src="https://i.imgur.com/AgdKc8N.jpg" alt=""></p>
<ul>
<li>INC為<strong>運算碼</strong><ul>
<li>將運算元加一並將結果儲存在運算元所存放的位址或暫存器</li>
</ul>
</li>
<li>[100H]為<strong>運算元</strong><ul>
<li>表示資料存放在記憶體位址為100H的地方</li>
</ul>
</li>
</ul>
</li>
<li><p>擷取週期</p>
<ul>
<li><strong>擷取運算碼</strong><ol>
<li>PC→MAR<ul>
<li>PC將010H傳送給MAR，此時<strong>MAR為010H</strong></li>
</ul>
</li>
<li>PC+1→PC<ul>
<li>PC自己加1，此時<strong>PC為011H</strong></li>
</ul>
</li>
<li>M(MAR)→MBR<ul>
<li>記憶體依據MAR所指定的位址<strong>010H將內部資料傳送給MBR</strong>，此時<strong>MBR為INC [100H]</strong></li>
</ul>
</li>
</ol>
</li>
<li>解碼<ol>
<li>(MBR)→IR<ul>
<li>MBR將指令解碼分為<strong>運算碼</strong>及<strong>運算元</strong>，<strong>將運算碼INC傳送給IR</strong>，此時<strong>IR為INC</strong></li>
</ul>
</li>
<li>IR→ID<ul>
<li>IR將運算碼傳送給ID，使<strong>ID產生控制信號ALU，告訴ALU將要執行的工作</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>執行週期</p>
<ul>
<li><strong>擷取運算元</strong><ol>
<li>(MBR)→MAR<ul>
<li>MBR將指令解碼分為運算碼及運算元，<strong>將運算元[100H]傳送給MAR</strong>，此時<strong>MAR為100H</strong></li>
</ul>
</li>
<li>M(MAR)→MBR<ul>
<li>記憶體依據MAR所指定的位址<strong>100H將內部資料傳送給MBR</strong>，此時<strong>MBR為2</strong></li>
</ul>
</li>
</ol>
</li>
<li>執行<ol>
<li>MBR→ALU<ul>
<li><strong>MBR將數值2傳送給ALU</strong>，並<strong>根據擷取週期時IR所傳送的INC加1的信號</strong>，使得數值2自動加1，<strong>ALU得3</strong></li>
</ul>
</li>
<li>ALU→MBR<ul>
<li>ALU將運算結果3傳送給MBR，此時<strong>MBR為3</strong></li>
</ul>
</li>
</ol>
</li>
<li>儲存執行結果<ol>
<li>MBR→M(MAR)<ul>
<li>MBR將3傳送給記憶體，其位址為MAR所指定的位址100H。所以目前<strong>記憶體位址100H所存放的資料為3</strong><br><img src="https://i.imgur.com/QqjobR4.jpg" alt=""></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>完整版本出處: <a href="http://www.chwa.com.tw/tresource/hs/book1/ch2/ch2-5.htm" target="_blank" rel="noopener">http://www.chwa.com.tw/tresource/hs/book1/ch2/ch2-5.htm</a></p>
</blockquote>
<h2 id="CPU指令-組合語言-介紹"><a href="#CPU指令-組合語言-介紹" class="headerlink" title="CPU指令(組合語言)介紹"></a>CPU指令(組合語言)介紹</h2><h3 id="計算機指令"><a href="#計算機指令" class="headerlink" title="計算機指令"></a>計算機指令</h3><ul>
<li>計算機通過指令指揮工作</li>
<li>CPU被PC驅動，不斷讀取PC指向的指令並增加，從記憶體中讀取並執行(週而復始)</li>
<li>不同CPU架構使用不同的指令<ul>
<li>複雜指令集運算法CISC(Complex Instruction Set Computing)<ul>
<li>指令多達200個以上</li>
<li>彈性較大且容易使用</li>
<li>電腦解讀速度較慢</li>
<li>大多數傳統的CPU所採用</li>
<li>Intel 80X86系列、AMD K6系列、Cyrix的M2系列…</li>
</ul>
</li>
<li>精簡指令集運算法RISC(Reduced Instruction Set Computing)<ul>
<li>撰寫出來的程式較長</li>
<li>執行程式的效率較CISC高</li>
<li>目前大多數的CPU架構</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MIPS-32指令範例"><a href="#MIPS-32指令範例" class="headerlink" title="MIPS-32指令範例"></a>MIPS-32指令範例</h3><ol>
<li><img src="https://i.imgur.com/Lwzef0F.png" alt=""><ul>
<li>屬於I-format</li>
<li>前六碼OP code為2，為跳轉指令</li>
<li>跳轉到後方的520位址</li>
</ul>
</li>
<li><img src="https://i.imgur.com/3fdVUO1.png" alt=""><ul>
<li>屬於R-format</li>
<li>前六碼OP code為0，代表兩寄/暫存器間的計算</li>
<li>OP code為0，funct為0x20，代表加法指令</li>
<li>rs為來源寄/暫存器，rt為目標寄/暫存器，rd為目的地寄/暫存器(存放結果)</li>
<li>shift因為為加法，偏移量為0</li>
</ul>
</li>
<li><img src="https://i.imgur.com/cRGsorz.png" alt=""><ul>
<li>屬於I-format</li>
<li>前六碼OP code為25，代表從記憶體中讀取值至寄/暫存器中</li>
<li>從rt5中讀取值和offset相加，存入rs3中</li>
</ul>
</li>
</ol>
<h3 id="輔助記憶碼-mnemonic"><a href="#輔助記憶碼-mnemonic" class="headerlink" title="輔助記憶碼(mnemonic)"></a>輔助記憶碼(mnemonic)</h3><ul>
<li>32位RISC指令集中，OP code是6位數，因此使用輔助記憶碼來幫助記憶<ul>
<li>0b000000(add)<ul>
<li>兩寄/暫存器相加</li>
</ul>
</li>
<li>0b000008(addi)<ul>
<li>寄/暫存器和數字相加</li>
</ul>
</li>
<li>0b100000(lb)<ul>
<li>把1字節從記憶體中讀出至寄/暫存器</li>
</ul>
</li>
<li>0b100011(lw)<ul>
<li>把4個字節從記憶體中讀出至寄/暫存器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="尋址模式（Addressing-modes）"><a href="#尋址模式（Addressing-modes）" class="headerlink" title="尋址模式（Addressing modes）"></a>尋址模式（Addressing modes）</h3><blockquote>
<p>指令集一部分，決定指令有幾個操作符，地址如何運算</p>
</blockquote>
<h4 id="R-format"><a href="#R-format" class="headerlink" title="R-format"></a>R-format</h4><p><img src="https://i.imgur.com/yuTcmiO.jpg" alt=""></p>
<ul>
<li>寄/暫存器尋址<ul>
<li>操作符是寄/暫存器，利用n位尋址2的n次個寄/暫存器</li>
<li>範例: add $r10, $r1, $r2</li>
</ul>
</li>
</ul>
<h4 id="I-format"><a href="#I-format" class="headerlink" title="I-format"></a>I-format</h4><p><img src="https://i.imgur.com/Jxlyb8n.png" alt=""></p>
<ul>
<li>立即尋址<ul>
<li>操作符中有值</li>
<li>範例: addi $r1, $zero, 1000</li>
<li>rs = $r1，rt = $zero，</li>
<li>數字大小有限制，32位就是(-2的15次(-32768)~(32768)2的15次)</li>
</ul>
</li>
<li>偏移量尋址<ul>
<li>根據源寄/暫存器地址和偏移量進行尋址，最終地址在源寄/暫存器地址和偏移量上運算</li>
<li>範例: lw $r0, 8($sp)</li>
<li>rt = $r0，rs = $sp</li>
</ul>
</li>
<li>PC相對尋址<ul>
<li>下個PC位址依賴目前位址到Label的距離</li>
<li>範例: beq $r3, $r9, LABEL</li>
<li>if else、goto等語法中用到</li>
</ul>
</li>
</ul>
<h3 id="記憶體讀取和寫入"><a href="#記憶體讀取和寫入" class="headerlink" title="記憶體讀取和寫入"></a>記憶體讀取和寫入</h3><ul>
<li>load/store指令用來從記憶體中讀取/寫入記憶體<ul>
<li>load<ul>
<li>lw(load word，4byte)</li>
<li>lb(load byte，1byte)</li>
<li>lh(load half，2byte)</li>
</ul>
</li>
<li>store<ul>
<li>sw(store word，4byte)</li>
<li>sb(store byte，1byte)</li>
<li>sh(store half，2byte)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="數學運算"><a href="#數學運算" class="headerlink" title="數學運算"></a>數學運算</h3><ul>
<li>加減乘除<ul>
<li>立即尋址 addi, subi, divi, multi<ul>
<li>addi $sp, $sp, 4</li>
</ul>
</li>
<li>寄/暫存器尋址 add, sub, div, mult<ul>
<li>add $d, $rs, $rt</li>
</ul>
</li>
<li>亦有其他尋址方式</li>
</ul>
</li>
<li>邏輯運算<ul>
<li>AND<ul>
<li>and $t0 $t1 $t2</li>
<li>$t1,$t2 做AND判斷，結果存入$t0</li>
</ul>
</li>
<li>OR<ul>
<li>or $t0 $t1 $t2</li>
<li>$t1,$t2 做OR判斷，結果存入$t0</li>
</ul>
</li>
<li>XOR<ul>
<li>nor $t0 $t1 $zero</li>
<li>使用NOR和$zero來判斷，結果存入$t0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="浮點數"><a href="#浮點數" class="headerlink" title="浮點數"></a>浮點數</h3><ul>
<li>十進位中0.1代表1/10，二進位0.1代表1/2，0.01代表1/4</li>
<li>0.375二進位中為0.011 = 1/4 + 1/8</li>
<li>Double表示<ul>
<li></li>
</ul>
</li>
</ul>
<h2 id="彙編指令如何實現複雜功能—遞迴"><a href="#彙編指令如何實現複雜功能—遞迴" class="headerlink" title="彙編指令如何實現複雜功能—遞迴"></a>彙編指令如何實現複雜功能—遞迴</h2><h2 id="中斷和中斷向量表"><a href="#中斷和中斷向量表" class="headerlink" title="中斷和中斷向量表"></a>中斷和中斷向量表</h2>]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Computer</tag>
        <tag>Compiler</tag>
        <tag>Interview</tag>
        <tag>Note</tag>
      </tags>
  </entry>
</search>
